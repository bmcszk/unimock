---
description: 
globs: 
alwaysApply: true
---
# Go Development Guidelines

## Core Principles & Practices
- **Interfaces:**
    - Define per consumer needs (Interface Segregation Principle).
    - Create only when necessary (polymorphism, testing, decoupling). Avoid premature/excessive interface creation.
- **Auto-generated Files:** Never apply Go rules, formatting, or refactoring to files with "DO NOT EDIT" comments.
- **Service Structure (Packages):**
    - `handler`: API/request handling.
    - `service`: Business logic.
    - `storage`: Data persistence.
    - `model`: Core data structures (if not co-located or generated by e.g., sqlc).
- **Logging:** Use `slog` for structured logging. Avoid standard `log` package for application logging.
- **Error Handling:** Wrap all returned errors with context: `fmt.Errorf("short descriptive context: %w", err)`.
- **Concurrency:** Use `errgroup` (`golang.org/x/sync/errgroup`) for managing concurrent goroutines.

## Recommended Libraries & Tools
- **Configuration:** `env` (`github.com/caarlos0/env`) for environment variable-based configuration.
- **HTTP Routing:** `Chi` (`github.com/go-chi/chi`).
- **Database Interaction (SQLC):**
    - Use `SQLC` (`docs.sqlc.dev`) for type-safe Go code generation for the relational data layer.
    - **Schema Source:** When using `SQLC` with `golang-migrate`, configure `SQLC` to read schema from the `golang-migrate` migration directory. Ensure lexicographical ordering of migration filenames (e.g., zero-padded).
- **Database Migrations:** `golang-migrate` (`github.com/golang-migrate/migrate`).
- **Event-Driven Systems:** `Watermill` (`watermill.io/`) for message queues and event-driven architecture.

## Development Methodology
- **Test-Driven Development (TDD):**
    1.  Create minimal code stub (empty function/struct).
    2.  Write a unit test against the stub (this test should initially fail).
    3.  Implement logic to make the test pass.
    - TDD is a development methodology, not just a testing strategy. It ensures tests validate intended functionality from the start.

## Testing Strategy
- **Categorization:**
    - **Unit Tests (`//go:build unit`):**
        - Test individual components (functions, structs) in isolation.
        - Mock/stub ALL external dependencies (DB, APIs, other services).
        - Utilize the `testify` library for assertions (`github.com/stretchr/testify/assert` or `github.com/stretchr/testify/require`).
        - Employ the `testify/mock` library for creating mocks for unit tests (`github.com/stretchr/testify/mock`).
        - Must be fast; NO Docker or external services required.
    - **End-to-End (E2E) / Integration Tests (`//go:build e2e`):**
        - Test system behavior (whole or integrated parts).
        - BDD style. For guidance on structuring cucumber-like tests without relying on specific libraries like Godog, refer to the patterns used in `github.com/bmcszk/effective-monorepo/tree/feature/tilt/e2e`.
        - For mocking 3rd party REST services during E2E tests, use `unimock` (`github.com/bmcszk/unimock`).
        - Require running application and dependencies (e.g., via Docker Compose).
- **Execution:** Both unit and E2E tests MUST be runnable via dedicated Makefile targets (e.g., `make test-unit`, `make test-e2e`).

## Code Quality & Workflow
- **Pre-commit Checks (`make check`):**
    - A single Makefile target (e.g., `make check`) MUST verify Go code quality before commits.
    - This target MUST include:
        - `go build ./...`
        - `golangci-lint run`
        - Unit tests (e.g., `make test-unit` or `go test -tags=unit ./...`)
    - MUST NOT require Docker or external services.
