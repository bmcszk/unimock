package config

import (
	"errors"
	"fmt"
	"os"
	"strings"

	"gopkg.in/yaml.v3"

	"github.com/bmcszk/unimock/pkg/model"
)

// ScenariosConfig represents the structure of a scenarios YAML file
type ScenariosConfig struct {
	// Scenarios contains a list of predefined scenarios to load at startup
	Scenarios []ScenarioFile `yaml:"scenarios" json:"scenarios"`
}

// ScenarioFile represents a scenario definition in the YAML file
// It mirrors the model.Scenario structure but allows for flexible YAML parsing
type ScenarioFile struct {
	// UUID is the unique identifier for the scenario (optional, auto-generated if empty)
	UUID string `yaml:"uuid,omitempty" json:"uuid,omitempty"`

	// Method is the HTTP method for this scenario (e.g., "GET", "POST", etc.)
	Method string `yaml:"method" json:"method"`

	// Path is the URL path pattern this scenario should match
	Path string `yaml:"path" json:"path"`

	// StatusCode is the HTTP status code to return (default: 200)
	StatusCode int `yaml:"status_code,omitempty" json:"status_code,omitempty"`

	// ContentType is the MIME type for the response (default: "application/json")
	ContentType string `yaml:"content_type,omitempty" json:"content_type,omitempty"`

	// Location header for redirects or resource creation responses
	Location string `yaml:"location,omitempty" json:"location,omitempty"`

	// Data is the response body content
	Data string `yaml:"data,omitempty" json:"data,omitempty"`

	// Headers contains additional HTTP headers to include in the response
	Headers map[string]string `yaml:"headers,omitempty" json:"headers,omitempty"`
}

// LoadScenariosFromYAML loads scenarios from a YAML file at the given path
func LoadScenariosFromYAML(path string) (*ScenariosConfig, error) {
	if path == "" {
		return &ScenariosConfig{Scenarios: []ScenarioFile{}}, nil
	}

	data, err := os.ReadFile(path)
	if err != nil {
		if os.IsNotExist(err) {
			return nil, fmt.Errorf("scenarios file not found: %s", path)
		}
		return nil, fmt.Errorf("failed to read scenarios file %s: %w", path, err)
	}

	config := &ScenariosConfig{}
	if err := yaml.Unmarshal(data, config); err != nil {
		return nil, fmt.Errorf("failed to parse scenarios YAML file %s: %w", path, err)
	}

	if err := validateScenariosConfig(config); err != nil {
		return nil, fmt.Errorf("invalid scenarios file %s: %w", path, err)
	}

	return config, nil
}

// ToModelScenarios converts ScenarioFile entries to model.Scenario entries
func (sc *ScenariosConfig) ToModelScenarios() []model.Scenario {
	scenarios := make([]model.Scenario, 0, len(sc.Scenarios))

	for _, sf := range sc.Scenarios {
		scenario := sf.toModelScenario()
		scenarios = append(scenarios, scenario)
	}

	return scenarios
}

// toModelScenario converts a ScenarioFile to a model.Scenario
func (sf *ScenarioFile) toModelScenario() model.Scenario {
	// Set defaults
	statusCode := sf.StatusCode
	if statusCode == 0 {
		statusCode = 200
	}

	contentType := sf.ContentType
	if contentType == "" {
		contentType = "application/json"
	}

	// Combine method and path into RequestPath format
	requestPath := fmt.Sprintf("%s %s", strings.ToUpper(sf.Method), sf.Path)

	return model.Scenario{
		UUID:        sf.UUID, // Will be auto-generated by scenario service if empty
		RequestPath: requestPath,
		StatusCode:  statusCode,
		ContentType: contentType,
		Location:    sf.Location,
		Data:        sf.Data,
		Headers:     sf.Headers,
	}
}

// validateScenariosConfig validates the scenarios configuration
func validateScenariosConfig(config *ScenariosConfig) error {
	if config == nil {
		return errors.New("scenarios config is nil")
	}

	for i, scenario := range config.Scenarios {
		if err := validateScenarioFile(&scenario, i); err != nil {
			return err
		}
	}

	return nil
}

// validateScenarioFile validates a single scenario file entry
func validateScenarioFile(sf *ScenarioFile, index int) error {
	if err := validateScenarioMethod(sf, index); err != nil {
		return err
	}

	if err := validateScenarioPath(sf, index); err != nil {
		return err
	}

	return validateScenarioStatusCode(sf, index)
}

// validateScenarioMethod validates the HTTP method
func validateScenarioMethod(sf *ScenarioFile, index int) error {
	if sf.Method == "" {
		return fmt.Errorf("scenario %d: method is required", index)
	}

	validMethods := []string{"GET", "HEAD", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"}
	method := strings.ToUpper(sf.Method)
	for _, vm := range validMethods {
		if method == vm {
			return nil
		}
	}

	return fmt.Errorf("scenario %d: invalid method %s, must be one of: %s", 
		index, sf.Method, strings.Join(validMethods, ", "))
}

// validateScenarioPath validates the URL path
func validateScenarioPath(sf *ScenarioFile, index int) error {
	if sf.Path == "" {
		return fmt.Errorf("scenario %d: path is required", index)
	}

	if !strings.HasPrefix(sf.Path, "/") {
		return fmt.Errorf("scenario %d: path must start with /", index)
	}

	return nil
}

// validateScenarioStatusCode validates the HTTP status code
func validateScenarioStatusCode(sf *ScenarioFile, index int) error {
	if sf.StatusCode != 0 && (sf.StatusCode < 100 || sf.StatusCode > 599) {
		return fmt.Errorf("scenario %d: invalid status code %d, must be between 100-599", 
			index, sf.StatusCode)
	}

	return nil
}