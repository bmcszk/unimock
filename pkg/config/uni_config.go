// Package config provides configuration structures for the Unimock server.
// It includes ServerConfig for server settings and UniConfig for mock behavior.
package config

import (
	"bytes"
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/bmcszk/unimock/pkg/model"
	"gopkg.in/yaml.v3"
)

const (
	// WildcardChar represents the single segment wildcard character used in path patterns
	WildcardChar = "*"
	// RecursiveWildcard represents the recursive wildcard for multiple segments
	RecursiveWildcard = "**"
	// PathSeparator represents the separator used in URL paths
	PathSeparator = "/"
	// noMatch represents an invalid match score
	noMatch = -1
)

// UniConfig represents the configuration for mock behavior
// It defines how Unimock handles different API endpoints and extracts IDs
// from various parts of HTTP requests.
type UniConfig struct {
	// Sections contains configuration for different API endpoint patterns
	// The map keys are section names (usually API resource names like "users" or "orders")
	// and the values are Section structs defining how to handle requests to those endpoints.
	// Supports both inline format (legacy) and explicit sections field (unified)
	Sections map[string]Section `yaml:"sections,omitempty" json:"sections"`

	// Scenarios contains predefined responses that override normal mock behavior
	Scenarios []ScenarioConfig `yaml:"scenarios,omitempty" json:"scenarios,omitempty"`

	// baseDir is the directory containing the configuration file (for fixture resolution)
	baseDir string

	// fixtureResolver handles loading fixture files referenced in configuration
	fixtureResolver *FixtureResolver
}

// ScenarioConfig represents a scenario definition in configuration
// It mirrors the model.Scenario structure but allows for flexible YAML parsing
type ScenarioConfig struct {
	// UUID is the unique identifier for the scenario (optional, auto-generated if empty)
	UUID string `yaml:"uuid,omitempty" json:"uuid,omitempty"`

	// Method is the HTTP method for this scenario (e.g., "GET", "POST", etc.)
	Method string `yaml:"method" json:"method"`

	// Path is the URL path pattern this scenario should match
	Path string `yaml:"path" json:"path"`

	// StatusCode is the HTTP status code to return (default: 200)
	StatusCode int `yaml:"status_code,omitempty" json:"status_code,omitempty"`

	// ContentType is the MIME type for the response (default: "application/json")
	ContentType string `yaml:"content_type,omitempty" json:"content_type,omitempty"`

	// Location header for redirects or resource creation responses
	Location string `yaml:"location,omitempty" json:"location,omitempty"`

	// Data is the response body content
	Data string `yaml:"data,omitempty" json:"data,omitempty"`

	// Headers contains additional HTTP headers to include in the response
	Headers map[string]string `yaml:"headers,omitempty" json:"headers,omitempty"`
}

// ToModelScenario converts a ScenarioConfig to a model.Scenario
// Optionally accepts a FixtureResolver to resolve fixture references in Data field
func (sf *ScenarioConfig) ToModelScenario(fixtureResolver *FixtureResolver) model.Scenario {
	// Set defaults
	statusCode := sf.StatusCode
	if statusCode == 0 {
		statusCode = 200
	}

	contentType := sf.ContentType
	if contentType == "" {
		contentType = "application/json"
	}

	// Resolve fixture references in data if resolver is provided
	data := sf.Data
	if fixtureResolver != nil {
		resolvedData, err := fixtureResolver.ResolveFixture(data)
		if err == nil {
			data = resolvedData
		}
		// If resolution fails, use original data (backward compatibility)
	}

	// Combine method and path into RequestPath format
	requestPath := fmt.Sprintf("%s %s", strings.ToUpper(sf.Method), sf.Path)

	return model.Scenario{
		UUID:        sf.UUID, // Will be auto-generated by scenario service if empty
		RequestPath: requestPath,
		StatusCode:  statusCode,
		ContentType: contentType,
		Location:    sf.Location,
		Data:        data,
		Headers:     sf.Headers,
	}
}

// IDExtractionConfig provides a simplified way to configure ID extraction
type IDExtractionConfig struct {
	// BodyPaths defines XPath-like paths to extract IDs from request bodies
	BodyPaths []string `yaml:"body_paths,omitempty" json:"body_paths,omitempty"`

	// HeaderNames specifies the HTTP header names to extract IDs from
	HeaderNames []string `yaml:"header_names,omitempty" json:"header_names,omitempty"`
}

// Section represents a configuration section for a specific API endpoint pattern
type Section struct {
	// PathPattern defines the URL pattern to match against.
	// Use * as a wildcard for single path segments, e.g. "/users/*" or "/users/*/orders/*"
	// Use ** as a wildcard for multiple path segments recursively, e.g. "/api/**"
	PathPattern string `yaml:"path_pattern" json:"path_pattern"`

	// StrictPath determines whether GET/PUT/DELETE operations require path structure compatibility.
	// When true:
	//   - Resources are only accessible via paths that extend their creation path
	//   - Example: Resource created at "/users/subpath" accessible via "/users/subpath/123" but not "/users/123"
	//   - PUT returns 404 if resource doesn't exist (no upsert behavior)
	//   - Enforces strict path structure validation for cross-path access prevention
	// When false (default):
	//   - Resources accessible via any path matching the section pattern (flexible cross-path access)
	//   - Example: Resource created at "/users/subpath" accessible via both "/users/subpath/123" and "/users/123"
	//   - PUT performs upsert operations (creates if doesn't exist)
	//   - Backward compatible behavior with flexible path matching
	StrictPath bool `yaml:"strict_path" json:"strict_path"`

	// BodyIDPaths defines the XPath-like paths to extract IDs from request bodies.
	// For JSON:
	//   - Use "/" to start from root
	//   - Use element names to navigate
	//   - Use "//" to search anywhere
	//   - Use "*" as wildcard
	//   - Use "text()" to get text content
	// Examples:
	//   - "/id" - extracts ID from root object
	//   - "/data/id" - extracts ID from nested object
	//   - "//id" - extracts any ID element anywhere
	//   - "/items/*/id" - extracts IDs from array of objects
	//   - "/user/id" - extracts ID from specific object
	//   - "//id[text()='123']" - extracts ID with specific value
	//
	// For XML:
	//   - Use "/" to start from root
	//   - Use element names to navigate
	//   - Use "//" to search anywhere
	//   - Use "*" as wildcard
	//   - Use "text()" to get text content
	// Examples:
	//   - "/root/id" - extracts ID from root element
	//   - "//id" - extracts any ID element
	//   - "/root/items/item/id" - extracts IDs from nested elements
	//   - "/root/*/id" - extracts IDs from any direct child
	//   - "//id[text()='123']" - extracts ID with specific value
	BodyIDPaths []string `yaml:"body_id_paths" json:"body_id_paths"`

	// HeaderIDNames specifies the HTTP header names to extract IDs from.
	// Multiple headers can be specified to support different ID extraction methods.
	// If empty, no header-based ID extraction will be performed.
	HeaderIDNames []string `yaml:"header_id_names,omitempty" json:"header_id_names,omitempty"`

	// IDExtraction provides a simplified way to configure ID extraction in unified config
	IDExtraction *IDExtractionConfig `yaml:"id_extraction,omitempty" json:"id_extraction,omitempty"`

	// CaseSensitive determines whether path matching is case-sensitive.
	// If true, paths must match exactly including case.
	// If false, paths are matched case-insensitively.
	CaseSensitive bool `yaml:"case_sensitive" json:"case_sensitive"`

	// ReturnBody determines whether POST/PUT/DELETE operations should return the resource body.
	// When true, successful POST/PUT/DELETE operations return the created/updated resource in the response body.
	// When false (default), successful operations return an empty body with appropriate status codes.
	// This flag provides simple control over response body behavior without requiring transformations.
	ReturnBody bool `yaml:"return_body" json:"return_body"`

	// Transformations contains request/response transformation functions.
	// This field is only available when using Unimock as a library and is excluded from YAML serialization.
	// It allows programmatic modification of requests and responses for advanced testing scenarios.
	Transformations *TransformationConfig `yaml:"-" json:"-"`
}

// NewUniConfig creates an empty UniConfig with an initialized Sections map
func NewUniConfig() *UniConfig {
	return &UniConfig{
		Sections:  make(map[string]Section),
		Scenarios: []ScenarioConfig{},
	}
}

// LoadFromYAML loads a UniConfig from a YAML file at the given path
// Supports both legacy format (sections at root) and unified format (sections nested)
func LoadFromYAML(path string) (*UniConfig, error) {
	data, err := os.ReadFile(path)
	if err != nil {
		return nil, err
	}

	// Try to parse as unified format first (with explicit sections and scenarios)
	config := NewUniConfig()
	decoder := yaml.NewDecoder(bytes.NewReader(data))
	decoder.KnownFields(false) // Disable strict mode for format detection

	unifiedErr := decoder.Decode(config)
	if unifiedErr == nil && (len(config.Sections) > 0 || len(config.Scenarios) > 0) {
		// Successfully parsed as unified format
		config.Normalize()
		config.initializeFixtureResolver(filepath.Dir(path))
		return config, nil
	}

	// Fall back to legacy format (sections as inline root-level keys)
	config = NewUniConfig()

	// For legacy format, we need to parse sections as inline root-level keys
	// Create a temporary struct with inline sections
	var legacyConfig struct {
		Sections map[string]Section `yaml:",inline"`
	}
	legacyConfig.Sections = make(map[string]Section)

	decoder = yaml.NewDecoder(bytes.NewReader(data))
	decoder.KnownFields(true) // Enable strict mode for legacy format

	if err := decoder.Decode(&legacyConfig); err != nil {
		// If both formats failed, return the unified format error for better debugging
		if unifiedErr != nil {
			return nil, unifiedErr
		}
		return nil, err
	}

	config.Sections = legacyConfig.Sections
	config.initializeFixtureResolver(filepath.Dir(path))
	return config, nil
}

// initializeFixtureResolver sets up the fixture resolver with the configuration file's directory
func (uc *UniConfig) initializeFixtureResolver(baseDir string) {
	uc.baseDir = baseDir
	uc.fixtureResolver = NewFixtureResolver(baseDir)
}

// GetFixtureResolver returns the fixture resolver for this configuration
func (uc *UniConfig) GetFixtureResolver() *FixtureResolver {
	return uc.fixtureResolver
}

// Normalize ensures consistent field values across different configuration formats
func (uc *UniConfig) Normalize() {
	for name, section := range uc.Sections {
		section.Normalize()
		uc.Sections[name] = section
	}
}

// Normalize ensures consistent field values for different configuration formats
func (s *Section) Normalize() {
	s.normalizePathFields()
	s.normalizeIDExtractionFields()
}

// normalizePathFields handles path field variants (no longer needed - only PathPattern supported)
func (*Section) normalizePathFields() {
	// No normalization needed - only PathPattern is supported
}

// normalizeIDExtractionFields handles ID extraction field variants
func (s *Section) normalizeIDExtractionFields() {
	if s.IDExtraction == nil {
		return
	}

	if len(s.BodyIDPaths) == 0 && len(s.IDExtraction.BodyPaths) > 0 {
		s.BodyIDPaths = s.IDExtraction.BodyPaths
	}
	if len(s.HeaderIDNames) == 0 && len(s.IDExtraction.HeaderNames) > 0 {
		s.HeaderIDNames = s.IDExtraction.HeaderNames
	}
}

// GetPathPattern returns the path pattern
func (s *Section) GetPathPattern() string {
	return s.PathPattern
}

// isPatternMatch checks if a path matches a pattern with wildcards
func isPatternMatch(pattern, path string, caseSensitive bool) bool {
	matcher := pathMatcher{caseSensitive: caseSensitive}
	patternParts := strings.Split(strings.Trim(pattern, PathSeparator), PathSeparator)
	pathParts := strings.Split(strings.Trim(path, PathSeparator), PathSeparator)

	if !strings.Contains(pattern, WildcardChar) {
		return matcher.matchExactPath(pattern, path)
	}

	// Check for recursive wildcard patterns
	if strings.Contains(pattern, RecursiveWildcard) {
		return matcher.matchRecursivePattern(patternParts, pathParts)
	}

	return matcher.matchWildcardPattern(patternParts, pathParts)
}

// pathMatcher handles path matching with configurable case sensitivity
type pathMatcher struct {
	caseSensitive bool
}

// matchExactPath performs exact path matching
func (pm pathMatcher) matchExactPath(pattern, path string) bool {
	if pm.caseSensitive {
		return pattern == path
	}
	return strings.EqualFold(pattern, path)
}

// matchWildcardPattern performs wildcard pattern matching
func (pm pathMatcher) matchWildcardPattern(patternParts, pathParts []string) bool {
	if !isValidSegmentCount(patternParts, pathParts) {
		return false
	}

	return pm.matchSegments(patternParts, pathParts)
}

// isValidSegmentCount checks if segment counts are compatible for single wildcards
func isValidSegmentCount(patternParts, pathParts []string) bool {
	// For single wildcard patterns, the segment count must match exactly
	// OR for collection access, allow one less segment (e.g., /users/* matches /users)
	return len(patternParts) == len(pathParts) ||
		(len(patternParts) > 0 && len(pathParts) == len(patternParts)-1 &&
			patternParts[len(patternParts)-1] == WildcardChar)
}

// matchSegments compares pattern segments with path segments
func (pm pathMatcher) matchSegments(patternParts, pathParts []string) bool {
	// Handle collection access case: /users/* matches /users
	if pm.isCollectionAccess(patternParts, pathParts) {
		return pm.matchCollectionSegments(patternParts, pathParts)
	}

	return pm.matchNormalSegments(patternParts, pathParts)
}

// isCollectionAccess checks if this is a collection access pattern
func (*pathMatcher) isCollectionAccess(patternParts, pathParts []string) bool {
	return len(pathParts) == len(patternParts)-1 && len(patternParts) > 0 &&
		patternParts[len(patternParts)-1] == WildcardChar
}

// matchCollectionSegments matches collection access patterns
func (pm pathMatcher) matchCollectionSegments(patternParts, pathParts []string) bool {
	for i := 0; i < len(pathParts); i++ {
		if !pm.segmentMatches(patternParts[i], pathParts[i]) {
			return false
		}
	}
	return true
}

// matchNormalSegments matches normal patterns with exact segment counts
func (pm pathMatcher) matchNormalSegments(patternParts, pathParts []string) bool {
	maxLen := len(patternParts)
	if len(pathParts) < maxLen {
		maxLen = len(pathParts)
	}

	for i := 0; i < maxLen; i++ {
		if patternParts[i] == WildcardChar {
			continue
		}
		if !pm.segmentMatches(patternParts[i], pathParts[i]) {
			return false
		}
	}
	return true
}

// segmentMatches checks if a single segment matches
func (pm pathMatcher) segmentMatches(pattern, path string) bool {
	if pm.caseSensitive {
		return pattern == path
	}
	return strings.EqualFold(pattern, path)
}

// matchRecursivePattern handles patterns with ** recursive wildcards
func (pm pathMatcher) matchRecursivePattern(patternParts, pathParts []string) bool {
	return pm.matchRecursiveSegments(patternParts, pathParts, 0, 0)
}

// matchRecursiveSegments recursively matches pattern segments with path segments
func (pm pathMatcher) matchRecursiveSegments(patternParts, pathParts []string, patternIdx, pathIdx int) bool {
	// Check if all patterns consumed
	if patternIdx >= len(patternParts) {
		return pathIdx >= len(pathParts)
	}

	// Check if all paths consumed but patterns remain
	if pathIdx >= len(pathParts) {
		return allRemainingAreRecursiveWildcards(patternParts, patternIdx)
	}

	currentPattern := patternParts[patternIdx]

	switch currentPattern {
	case RecursiveWildcard:
		return pm.handleRecursiveWildcard(patternParts, pathParts, patternIdx, pathIdx)
	case WildcardChar:
		return pm.handleSingleWildcard(patternParts, pathParts, patternIdx, pathIdx)
	default:
		return pm.handleExactMatch(patternParts, pathParts, patternIdx, pathIdx, currentPattern)
	}
}

// allRemainingAreRecursiveWildcards checks if remaining pattern parts are all ** wildcards
func allRemainingAreRecursiveWildcards(patternParts []string, patternIdx int) bool {
	for i := patternIdx; i < len(patternParts); i++ {
		if patternParts[i] != RecursiveWildcard {
			return false
		}
	}
	return true
}

// handleRecursiveWildcard processes ** wildcards
func (pm pathMatcher) handleRecursiveWildcard(patternParts, pathParts []string, patternIdx, pathIdx int) bool {
	// ** can match zero or more segments
	for i := pathIdx; i <= len(pathParts); i++ {
		if pm.matchRecursiveSegments(patternParts, pathParts, patternIdx+1, i) {
			return true
		}
	}
	return false
}

// handleSingleWildcard processes * wildcards
func (pm pathMatcher) handleSingleWildcard(patternParts, pathParts []string, patternIdx, pathIdx int) bool {
	// * matches exactly one segment
	return pm.matchRecursiveSegments(patternParts, pathParts, patternIdx+1, pathIdx+1)
}

// handleExactMatch processes exact segment matches
func (pm pathMatcher) handleExactMatch(
	patternParts, pathParts []string, patternIdx, pathIdx int, currentPattern string,
) bool {
	if pm.segmentMatches(currentPattern, pathParts[pathIdx]) {
		return pm.matchRecursiveSegments(patternParts, pathParts, patternIdx+1, pathIdx+1)
	}
	return false
}

// MatchPath finds the section that matches the given path
func (uc *UniConfig) MatchPath(path string) (string, *Section, error) {
	normalizedPath := strings.Trim(path, PathSeparator)

	// First try exact matches (no wildcards)
	if name, section := uc.findExactMatch(normalizedPath); section != nil {
		return name, section, nil
	}

	// Then try wildcard matches, prioritizing longer patterns
	if name, section := uc.findBestWildcardMatch(normalizedPath); section != nil {
		return name, section, nil
	}

	return "", nil, nil // No match found
}

// findExactMatch looks for exact pattern matches (no wildcards)
func (uc *UniConfig) findExactMatch(normalizedPath string) (string, *Section) {
	for name, section := range uc.Sections {
		pattern := strings.Trim(section.PathPattern, PathSeparator)
		if !strings.Contains(pattern, WildcardChar) {
			if isPatternMatch(pattern, normalizedPath, section.CaseSensitive) {
				s := section // Create a local copy
				return name, &s
			}
		}
	}
	return "", nil
}

// findBestWildcardMatch finds the best wildcard match by prioritizing longer patterns
func (uc *UniConfig) findBestWildcardMatch(normalizedPath string) (string, *Section) {
	bestMatch := wildcardMatch{name: "", numSegments: noMatch}

	for name, section := range uc.Sections {
		if match := uc.evaluateWildcardSection(name, section, normalizedPath); match.isValid() {
			if match.isBetterThan(bestMatch) {
				bestMatch = match
			}
		}
	}

	return bestMatch.getResult(uc)
}

// wildcardMatch represents a potential wildcard match
type wildcardMatch struct {
	name        string
	numSegments int
}

// isValid checks if the match is valid
func (m wildcardMatch) isValid() bool {
	return m.name != ""
}

// isBetterThan checks if this match is better than another
func (m wildcardMatch) isBetterThan(other wildcardMatch) bool {
	return m.numSegments > other.numSegments
}

// getResult returns the section for this match
func (m wildcardMatch) getResult(uc *UniConfig) (string, *Section) {
	if !m.isValid() {
		return "", nil
	}
	matchedSection := uc.Sections[m.name]
	return m.name, &matchedSection
}

// evaluateWildcardSection checks if a section matches and returns match info
func (*UniConfig) evaluateWildcardSection(name string, section Section, normalizedPath string) wildcardMatch {
	pattern := strings.Trim(section.PathPattern, PathSeparator)

	if !strings.Contains(pattern, WildcardChar) {
		return wildcardMatch{}
	}

	if !isPatternMatch(pattern, normalizedPath, section.CaseSensitive) {
		return wildcardMatch{}
	}

	// Calculate match score: prefer patterns with more specific segments
	// ** wildcards get lower priority than specific segments or *
	numSegments := len(strings.Split(pattern, PathSeparator))

	// Adjust score based on wildcard types
	score := numSegments * 100 // Base score
	patternParts := strings.Split(pattern, PathSeparator)
	for _, part := range patternParts {
		switch part {
		case RecursiveWildcard:
			score -= 50 // ** wildcards are less specific
		case WildcardChar:
			score -= 10 // * wildcards are somewhat less specific
		default:
			// Exact segments don't modify the score (most specific)
		}
	}

	return wildcardMatch{name: name, numSegments: score}
}
